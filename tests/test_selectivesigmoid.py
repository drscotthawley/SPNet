# -*- coding: utf-8 -*-
"""SelectiveSigmoid_Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mCqvvGsnaUW_kCG7qiv5LsPkqkmN7fP3
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x
from keras.layers import Input
from keras.models import Model
import keras.backend as K
from keras.engine.topology import Layer
import tensorflow as tf
import numpy as np
import sys
sys.path.append("../")

import spnet.config as cf
from spnet.models import SelectiveSigmoid

'''
vars_per_pred = 8
ind_cx = 0
ind_cy = 1
ind_semi_a = 2
ind_semi_b = 3
ind_angle1 = 4          # cos(2*theta)
ind_angle2 = 5          # sin(2*theta)
ind_noobj = 6
ind_rings = 7

class SelectiveSigmoid(Layer):
    """
    Applies sigmoid activation to only certain strided variables in a layer,
    leaves the other values untouched (i.e. linear activation)
    """
    def __init__(self, **kwargs):
        self.start = kwargs.get('start', ind_noobj)
        self.end = kwargs.get('end', None)
        self.skip = kwargs.get('skip', vars_per_pred)
        self.sigmoid_stretch = 1                        # some ppl make the sigmoid>1  (e.g. LeCun et al, "Efficient Backprop", 1998), but this will break CE loss
        super(SelectiveSigmoid, self).__init__(**kwargs)

    def build(self, input_shape):
        self.indices = np.zeros(input_shape[-1])           # Note that tf.cast (below) allows a numpy array
        self.indices[self.start:self.end:self.skip] = 1    # since it's numpy, we can do sliced assignment
        self.bool_inds = tf.cast(self.indices, dtype=tf.bool) # really we only want True/False

    def call(self, x):
        # in the following line, the transposing is necessary to obviate the need to know the batch_size
        xT = tf.transpose(x)
        return tf.transpose(tf.where(self.bool_inds, self.sigmoid_stretch*K.sigmoid(xT), xT ))

    def compute_output_shape(self, input_shape):
        return input_shape
'''


num_instances = 2
batch_member_shape = num_instances*cf.vars_per_pred

inp = Input(shape=(batch_member_shape,))
out = SelectiveSigmoid()(inp)
model = Model(inp, out)

batch_size = 2
inputs = np.random.rand(batch_size, batch_member_shape)-0.5
outputs = model.predict(inputs)
print("inputs = ",inputs)
print("outputs = ",outputs)

diff = outputs - inputs
print("ind_noobj = ",cf.ind_noobj)
print("vars_per_pred = ",cf.vars_per_pred)
print("diff = ",np.abs(diff)>1e-6)
print("differences at\n",np.argwhere(np.abs(diff)>1e-6 ))

def sigmoid(x):
    return 1/(1+np.exp(-x))

x = inputs[0,6]
ssx = outputs[0,6]
print("x, sigmoid(x), ss(x) = ", x, sigmoid(x), ssx)
